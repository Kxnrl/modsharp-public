/* 
 * ModSharp
 * Copyright (C) 2023-2025 Kxnrl. All Rights Reserved.
 *
 * This file is part of ModSharp.
 * ModSharp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * ModSharp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with ModSharp. If not, see <https://www.gnu.org/licenses/>.
 */

using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Sharp.Generator.Sdk.Utils;

namespace Sharp.Generator;

[Generator]
public class ModuleManagerGenerator : IIncrementalGenerator
{
    private const string GenerateAttributeName = "Sharp.Core.Attributes.LibraryModuleManagerAttribute";
    private const string ModuleAttributeName   = "Sharp.Core.Attributes.LibraryModuleAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classesToGenerate = context.SyntaxProvider
                                       .ForAttributeWithMetadataName(GenerateAttributeName,
                                                                     (node, _) => node is ClassDeclarationSyntax,
                                                                     GetClassToGenerate)
                                       .Where(static c => c is not null);

        context.RegisterSourceOutput(classesToGenerate,
                                     static (spc, source) => Execute(spc, source!));
    }

    private static ClassToGenerate? GetClassToGenerate(GeneratorAttributeSyntaxContext context,
        CancellationToken                                                              cancellationToken)
    {
        var classSymbol = (INamedTypeSymbol) context.TargetSymbol;

        var ns = classSymbol.ContainingNamespace.IsGlobalNamespace
            ? string.Empty
            : classSymbol.ContainingNamespace.ToDisplayString();

        var moduleProperties = new List<ModulePropertyInfo>();

        foreach (var member in classSymbol.GetMembers())
        {
            if (member is not IPropertySymbol propertySymbol)
            {
                continue;
            }

            var attribute = propertySymbol.GetAttributes()
                                          .FirstOrDefault(ad => ad.AttributeClass?.ToDisplayString() == ModuleAttributeName);

            if (attribute is not null && attribute.ConstructorArguments.Any())
            {
                var libraryName = attribute.ConstructorArguments[0].Value?.ToString() ?? string.Empty;

                if (!string.IsNullOrWhiteSpace(libraryName))
                {
                    moduleProperties.Add(new ModulePropertyInfo(propertySymbol.Name, libraryName));
                }
            }
        }

        return new ClassToGenerate(classSymbol.Name, ns, moduleProperties);
    }

    private static void Execute(SourceProductionContext context, ClassToGenerate classToGen)
    {
        var builder = new CodeWriter();

        builder.AppendLine($"""
                            // <auto-generated/>

                            #pragma warning disable 0649
                            #nullable enable

                            using System;

                            namespace {classToGen.Namespace};

                            """);

        using (builder.BeginScope($"partial class {classToGen.ClassName}"))
        {
            using (builder.BeginScope(
                       $"public {classToGen.ClassName}(Microsoft.Extensions.Logging.ILogger<{classToGen.ClassName}> logger)"))
            {
                builder.AppendLine("_logger = logger;");

                foreach (var prop in classToGen.ModuleProperties)
                {
                    builder.AppendLine(
                        $"{prop.PropertyName} = Sharp.Core.Bridges.Interfaces.LibraryModule.Create(Sharp.Core.Bridges.Natives.Core.GetLibraryModule(\"{prop.LibraryName}\")) ?? throw new EntryPointNotFoundException(\"Failed to get '{prop.PropertyName}' module\");");
                }
            }
        }

        context.AddSource($"{classToGen.ClassName}.g.cs", builder.ToString());
    }

    private record ModulePropertyInfo
    {
        public string PropertyName { get; }
        public string LibraryName  { get; }

        public ModulePropertyInfo(string propertyName, string libraryName)
        {
            PropertyName = propertyName;
            LibraryName  = libraryName;
        }
    }

    private record ClassToGenerate
    {
        public string                   ClassName        { get; }
        public string                   Namespace        { get; }
        public List<ModulePropertyInfo> ModuleProperties { get; }

        public ClassToGenerate(string className, string @namespace, List<ModulePropertyInfo> moduleProperties)
        {
            ClassName        = className;
            Namespace        = @namespace;
            ModuleProperties = moduleProperties;
        }
    }
}
