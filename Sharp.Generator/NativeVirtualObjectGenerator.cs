/* 
 * ModSharp
 * Copyright (C) 2023-2025 Kxnrl. All Rights Reserved.
 *
 * This file is part of ModSharp.
 * ModSharp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * ModSharp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with ModSharp. If not, see <https://www.gnu.org/licenses/>.
 */

using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Sharp.Generator.Sdk.Utils;

namespace Sharp.Generator;

[Generator]
public class NativeVirtualObjectGenerator : IIncrementalGenerator
{
    private const string Namespace     = "Sharp.Generator";
    private const string AttributeName = "NativeVirtualObjectAttribute";

    private const string AttributeSourceCode = $$"""
                                                 // <auto-generated/>

                                                 namespace {{Namespace}}
                                                 {
                                                     [System.AttributeUsage(System.AttributeTargets.Interface | System.AttributeTargets.Class)]
                                                     internal class {{AttributeName}} : System.Attribute
                                                     {
                                                         public bool HasDestructors { get; set; } = false;
                                                     }
                                                 }
                                                 """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{AttributeName}.g.cs",
                                                                      SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var provider = context.SyntaxProvider.CreateSyntaxProvider((x, _) => x is ClassDeclarationSyntax,
                                                                   (x, _) => GetClassDeclarationForSourceGen(x))
                              .Where(t => t.attributeFound)
                              .Select((t, _) => t.Item1);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
                                     (spc, source) => Execute(spc, source.Left, source.Right));
    }

    private static (ClassDeclarationSyntax, bool attributeFound) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax) context.Node;

        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (var attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax)
                       .Symbol is not IMethodSymbol attributeSymbol)
            {
                continue;
            }

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            if (attributeName == $"{Namespace}.{AttributeName}")
            {
                return (classDeclarationSyntax, true);
            }
        }

        return (classDeclarationSyntax, false);
    }

    private void Execute(SourceProductionContext context,
        Compilation                              compilation,
        ImmutableArray<ClassDeclarationSyntax>   classDeclarations)
    {
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
            {
                continue;
            }

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            var className = classDeclarationSyntax.Identifier.Text;

            var builder = new CodeWriter();

            builder.AppendLine($"""
                                // <auto-generated/>

                                #pragma warning disable 0649
                                #nullable enable

                                using System;
                                using System.Buffers;
                                using System.Runtime.InteropServices;
                                using System.Text;
                                using System.Text.Unicode;

                                namespace {namespaceName};

                                """);

            // get attribute data
            var hasDestructors = false;

            foreach (var attributeArg in classSymbol.GetAttributes().First().NamedArguments)
            {
                if (attributeArg is { Key: "HasDestructors" })
                {
                    hasDestructors = (bool) attributeArg.Value.Value!;
                }
            }

            using (builder.BeginScope($"unsafe partial class {classSymbol.Name}"))
            {
                var methods = classSymbol.GetMembers();

                var virtualOffset = hasDestructors ? 1 : 0;

                foreach (var method in methods)
                {
                    if (method is not IMethodSymbol { IsPartialDefinition: true } methodSymbol)
                    {
                        continue;
                    }

                    var fnParams                       = methodSymbol.GetParams();
                    var delegateUnmanagedPointerString = fnParams.GetDelegateUnmanagedPointerString("nint");

                    builder.AppendLine($"private static {delegateUnmanagedPointerString} _{methodSymbol.Name};");

                    using (builder.BeginScope(
                               $"public partial {methodSymbol.ReturnType} {methodSymbol.Name}({fnParams.GetParametersString()})"))
                    {
                        using (builder.BeginScope($"if (_{methodSymbol.Name} is null)"))
                        {
                            var linuxOffset = hasDestructors ? virtualOffset + 1 : virtualOffset;

                            builder.AppendLine(
                                $"_{methodSymbol.Name} = ({delegateUnmanagedPointerString})(*(nint*)(*(nint*) _this.ToPointer() + 8 * (RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? {linuxOffset} : {virtualOffset})));");
                        }

                        builder.AppendLine();

                        fnParams.BuildUtf8ConvertCode(builder);

                        fnParams.BuildCallAndReturnDelegateUnmanagedPointer(builder, $"_{methodSymbol.Name}", "_this");
                    }

                    builder.AppendLine();

                    virtualOffset++;
                }
            }

            context.AddSource($"{className}.g.cs", builder.ToString());
        }
    }
}
