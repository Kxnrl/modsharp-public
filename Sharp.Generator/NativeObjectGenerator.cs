/* 
 * ModSharp
 * Copyright (C) 2023-2025 Kxnrl. All Rights Reserved.
 *
 * This file is part of ModSharp.
 * ModSharp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * ModSharp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with ModSharp. If not, see <https://www.gnu.org/licenses/>.
 */

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Sharp.Generator.Sdk.Utils;

namespace Sharp.Generator;

[Generator]
public class NativeObjectGenerator : IIncrementalGenerator
{
    private const string Namespace     = "Sharp.Generator";
    private const string AttributeName = "NativeVirtualMethodAttribute";

    private const string AttributeSourceCode = $$"""
                                                 // <auto-generated/>

                                                 namespace {{Namespace}}
                                                 {
                                                     [System.AttributeUsage(System.AttributeTargets.Method)]
                                                     internal class {{AttributeName}} : System.Attribute
                                                     {
                                                         public int Offset { get; set; } = -1;
                                                         public int LinuxOffset { get; set; } = -1;
                                                     }
                                                 }
                                                 """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{AttributeName}.g.cs",
                                                                      SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var provider = context.SyntaxProvider.CreateSyntaxProvider((x, _) => x is ClassDeclarationSyntax,
                                                                   (x, _) => GetClassDeclarationForSourceGen(x))
                              .Where(t => t.interfaceFound)
                              .Select((t, _) => t.Item1);

        var compilation = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(compilation, (spc, source) => Execute(spc, source.Left, source.Right));
    }

    private static (ClassDeclarationSyntax, bool interfaceFound)
        GetClassDeclarationForSourceGen(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax) context.Node;

        if (context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is INamedTypeSymbol classSymbol)
        {
            if (classSymbol.AllInterfaces.Any(x => x.ToDisplayString() == "Sharp.Shared.CStrike.INativeObject"))
            {
                return (classDeclarationSyntax, true);
            }
        }

        return (classDeclarationSyntax, false);
    }

    private void Execute(SourceProductionContext context,
        Compilation                              compilation,
        ImmutableArray<ClassDeclarationSyntax>   classDeclarations)
    {
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
            {
                continue;
            }

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            var className = classDeclarationSyntax.Identifier.Text;

            // Skip self
            if (className.Equals("NativeObject")
                || className.Equals("SchemaObject")
                || className.Equals("EntityComponent")
                || className.Equals("EntitySubclassVData"))
            {
                continue;
            }

            var builder = new CodeWriter();

            builder.AppendLine($"""
                                // <auto-generated/>

                                #pragma warning disable 0649
                                #nullable enable

                                using System;
                                using System.Buffers;
                                using System.Runtime.InteropServices;
                                using System.Text;
                                using System.Text.Unicode;

                                namespace {namespaceName};

                                """);

            var methodSyntaxes = new List<MethodDeclarationSyntax>();

            foreach (var memberDeclarationSyntax in classDeclarationSyntax.Members)
            foreach (var attributeListSyntax in memberDeclarationSyntax.AttributeLists)
            foreach (var attributeSyntax in attributeListSyntax.Attributes)
            {
                if (semanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                {
                    continue;
                }

                var attributeName = attributeSymbol.ContainingType.ToDisplayString();

                if (attributeName != $"{Namespace}.{AttributeName}")
                {
                    continue;
                }

                if (memberDeclarationSyntax is MethodDeclarationSyntax methodDeclarationSyntax)
                {
                    methodSyntaxes.Add(methodDeclarationSyntax);
                }
            }

            using (builder.BeginScope($"unsafe partial class {classSymbol.Name}"))
            {
                var gameConVar          = classSymbol.AllInterfaces.Any(x => x.Name == "IConVar");
                var gameClient          = classSymbol.AllInterfaces.Any(x => x.Name == "IGameClient");
                var gameEntity          = classSymbol.AllInterfaces.Any(x => x.Name == "IBaseEntity");
                var pawnComponent       = classSymbol.AllInterfaces.Any(x => x.Name == "IPlayerPawnComponent");
                var controllerComponent = classSymbol.AllInterfaces.Any(x => x.Name == "IPlayerControllerComponent");

                var entityComponent = classSymbol.AllInterfaces.Any(x => x.Name == "IEntityComponent")
                                      && classSymbol.GetAttributes()
                                                    .Any(x => x.AttributeClass?.ToDisplayString()
                                                              == "Sharp.Core.Attributes.EntityComponentInfoAttribute");

                var entityObject = classSymbol.AllInterfaces.Any(x => x.Name == "IEntityObject")
                                   && classSymbol.GetAttributes()
                                                 .Any(x => x.AttributeClass?.ToDisplayString()
                                                           == "Sharp.Core.Attributes.EntityObjectInfoAttribute");

                var weaponData = classSymbol.AllInterfaces.Any(x => x.Name == "IWeaponData");
                var poolName   = $"_cached{classSymbol.Name}Pool";

                if (gameClient)
                {
                    builder.AppendLine(
                        $"internal static readonly Sharp.Core.Pools.ClientPool<{classSymbol.Name}> {poolName} = new();");
                }
                else if (gameConVar)
                {
                    builder.AppendLine(
                        $"internal static readonly Sharp.Core.Pools.ConVarPool<{classSymbol.Name}> {poolName} = new();");
                }
                else if (gameEntity)
                {
                    builder.AppendLine(
                        $"internal static readonly Sharp.Core.Pools.EntityPool<{classSymbol.Name}> {poolName} = new();");
                }
                else if (pawnComponent)
                {
                    builder.AppendLine(
                        $"internal static readonly Sharp.Core.Pools.PlayerPawnComponentPool<{classSymbol.Name}> {poolName} = new();");
                }
                else if (controllerComponent)
                {
                    builder.AppendLine(
                        $"internal static readonly Sharp.Core.Pools.PlayerControllerComponentPool<{classSymbol.Name}> {poolName} = new();");
                }
                else if (entityComponent)
                {
                    var attribute = classSymbol.GetAttributes()
                                               .Single(x => x.AttributeClass?.ToDisplayString()
                                                            == "Sharp.Core.Attributes.EntityComponentInfoAttribute");

                    var schemaClass = attribute.ConstructorArguments[0].Value as string;
                    var schemaField = attribute.ConstructorArguments[1].Value as string;

                    builder.AppendLine(
                        $"internal static readonly Sharp.Core.Pools.EntityComponentPool<{classSymbol.Name}> {poolName} = new(\"{schemaClass}\", \"{schemaField}\");");
                }
                else if (entityObject)
                {
                    var attribute = classSymbol.GetAttributes()
                                               .Single(x => x.AttributeClass?.ToDisplayString()
                                                            == "Sharp.Core.Attributes.EntityObjectInfoAttribute");

                    var offset = (int) attribute.ConstructorArguments[0].Value!;

                    builder.AppendLine(
                        $"internal static readonly Sharp.Core.Pools.EntityObjectPool<{classSymbol.Name}> {poolName} = new({offset});");
                }
                else if (weaponData)
                {
                    builder.AppendLine($"internal static readonly Sharp.Core.Pools.WeaponDataPool {poolName} = new();");
                }

                foreach (var methodDeclarationSyntax in methodSyntaxes)
                {
                    if (semanticModel.GetDeclaredSymbol(methodDeclarationSyntax) is not IMethodSymbol methodSymbol)
                    {
                        continue;
                    }

                    var fnParams                       = methodSymbol.GetParams();
                    var delegateUnmanagedPointerString = fnParams.GetDelegateUnmanagedPointerString("nint");

                    // get virtual offset
                    var virtualOffset      = -1;
                    var linuxVirtualOffset = -1;

                    if (methodSymbol.GetAttributes().FirstOrDefault()?.NamedArguments is { } attributeArgs)
                    {
                        foreach (var attributeArg in attributeArgs)
                        {
                            if (attributeArg is { Key: "Offset" })
                            {
                                virtualOffset = (int) attributeArg.Value.Value!;
                            }
                            else if (attributeArg is { Key: "LinuxOffset" })
                            {
                                linuxVirtualOffset = (int) attributeArg.Value.Value!;
                            }
                        }
                    }

                    builder.AppendLine($"private {delegateUnmanagedPointerString} _{methodSymbol.Name};");

                    using (builder.BeginScope(
                               $"public partial {methodSymbol.ReturnType} {methodSymbol.Name}({fnParams.GetParametersString()})"))
                    {
                        if (virtualOffset >= 0)
                        {
                            using (builder.BeginScope($"if (_{methodSymbol.Name} is null)"))
                            {
                                builder.AppendLine(
                                    $"_{methodSymbol.Name} = ({delegateUnmanagedPointerString})(*(nint*)(*(nint*) _this.ToPointer() + 8 * (RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? {linuxVirtualOffset} : {virtualOffset})));");
                            }
                        }

                        builder.AppendLine();

                        fnParams.BuildUtf8ConvertCode(builder);

                        fnParams.BuildCallAndReturnDelegateUnmanagedPointer(builder, $"_{methodSymbol.Name}", "_this");
                    }

                    builder.AppendLine();
                }

                if (!classSymbol.Constructors.Any(x => x.Parameters.Length > 0))
                {
                    using (builder.BeginScope($"protected {classSymbol.Name}(nint ptr) : base(ptr)"))
                    {
                    }
                }

                if (!classSymbol.GetMembers()
                                .Any(x => x.IsStatic
                                          && x is IMethodSymbol { Name: "Create" })
                    && !classSymbol.IsAbstract)
                {
                    using (builder.BeginScope($"public new static {classSymbol.Name}? Create(nint ptr)"))
                    {
                        using (builder.BeginScope($"if (ptr == nint.Zero)"))
                        {
                            builder.AppendLine("return null;");
                        }

                        if (gameClient)
                        {
                            using (builder.BeginScope($"if ({poolName}.Find(ptr) is {{ }} client)"))
                            {
                                using (builder.BeginScope($"if (ptr == client.GetAbsPtr())"))
                                {
                                    builder.AppendLine($"return client;");
                                }
                            }

                            builder.AppendLine($"client = new {classSymbol.Name}(ptr);");
                            builder.AppendLine($"{poolName}.Set(client);");
                            builder.AppendLine("return client;");
                        }
                        else if (gameConVar)
                        {
                            using (builder.BeginScope($"if ({poolName}.Find(ptr) is {{ }} cvar)"))
                            {
                                using (builder.BeginScope($"if (ptr == cvar.GetAbsPtr())"))
                                {
                                    builder.AppendLine($"return cvar;");
                                }
                            }

                            builder.AppendLine($"cvar = new {classSymbol.Name}(ptr);");
                            builder.AppendLine($"{poolName}.Set(cvar);");
                            builder.AppendLine("return cvar;");
                        }
                        else if (gameEntity)
                        {
                            builder.AppendLine("var handle = GetHandle(ptr);");

                            using (builder.BeginScope($"if ({poolName}.Find(handle) is {{ }} entity)"))
                            {
                                using (builder.BeginScope($"if (handle != entity.Handle)"))
                                {
                                    builder.AppendLine($"var newEntity = new {classSymbol.Name}(ptr);");

                                    builder.AppendLine(
                                        $"throw new AccessViolationException($\"handle mismatch: old<{{entity.GetAbsPtr()}}::{{entity.Handle.GetValue()}}> new<{{ptr}}::{{handle.GetValue()}}>\");");
                                }

                                using (builder.BeginScope($"if (ptr == entity.GetAbsPtr())"))
                                {
                                    builder.AppendLine($"return entity;");
                                }
                            }

                            builder.AppendLine($"entity = new {classSymbol.Name}(ptr);");
                            builder.AppendLine($"{poolName}.Set(entity);");
                            builder.AppendLine("return entity;");
                        }
                        else if (pawnComponent || controllerComponent || entityComponent || entityObject)
                        {
                            using (builder.BeginScope($"if ({poolName}.Find(ptr) is {{ }} component)"))
                            {
                                using (builder.BeginScope($"if (ptr == component.GetAbsPtr())"))
                                {
                                    builder.AppendLine($"return component;");
                                }
                            }

                            builder.AppendLine($"component = new {classSymbol.Name}(ptr);");
                            builder.AppendLine($"{poolName}.Set(component);");
                            builder.AppendLine("return component;");
                        }
                        else if (weaponData)
                        {
                            using (builder.BeginScope($"if ({poolName}.Find(ptr) is {{ }} data)"))
                            {
                                builder.AppendLine($"return data;");
                            }

                            builder.AppendLine($"data = new {classSymbol.Name}(ptr);");
                            builder.AppendLine($"{poolName}.Set(data);");
                            builder.AppendLine("return data;");
                        }
                        else
                        {
                            builder.AppendLine($"return new {classSymbol.Name}(ptr);");
                        }
                    }
                }
            }

            context.AddSource($"{className}.g.cs", builder.ToString());
        }
    }
}
