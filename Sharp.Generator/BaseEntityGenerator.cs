/* 
 * ModSharp
 * Copyright (C) 2023-2025 Kxnrl. All Rights Reserved.
 *
 * This file is part of ModSharp.
 * ModSharp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * ModSharp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with ModSharp. If not, see <https://www.gnu.org/licenses/>.
 */

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Sharp.Generator.Sdk.Utils;

namespace Sharp.Generator;

[Generator]
public class BaseEntityGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider((x, _) => x is ClassDeclarationSyntax,
                                                                   (x, _) => (ClassDeclarationSyntax) x.Node);

        var compilation = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(compilation,
                                     (spc, source) => Execute(spc, source.Left, source.Right));
    }

    private void Execute(SourceProductionContext context,
        Compilation                              compilation,
        ImmutableArray<ClassDeclarationSyntax>   syntaxList)
    {
        var               entityList                = new List<string>();
        INamedTypeSymbol? baseEntityClassTypeSymbol = null;

        foreach (var classDeclarationSyntax in syntaxList)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol namedTypeSymbol)
            {
                continue;
            }

            if (namedTypeSymbol.Name == "BaseEntity")
            {
                baseEntityClassTypeSymbol = namedTypeSymbol;

                continue;
            }

            if (namedTypeSymbol.AllInterfaces.All(x => x.Name != "IBaseEntity"))
            {
                continue;
            }

            entityList.Add(namedTypeSymbol.Interfaces.FirstOrDefault()?.Name ?? namedTypeSymbol.Name);
        }

        if (baseEntityClassTypeSymbol is not null)
        {
            var builder = new CodeWriter();

            var namespaceName = baseEntityClassTypeSymbol.ContainingNamespace.ToDisplayString();

            var className = "BaseEntity";

            builder.AppendLine($"""
                                // <auto-generated/>

                                #pragma warning disable 0649
                                #nullable enable

                                using System;
                                using System.Text.Unicode;
                                using Sharp.Core.GameEntities;
                                using Sharp.Shared.GameEntities;
                                using Sharp.Shared.Objects;

                                namespace {namespaceName};

                                """);

            using (builder.BeginScope($"partial class {className}"))
            {
                using (builder.BeginScope($"public T As<T>() where T : class, IBaseEntity"))
                {
                    builder.AppendLine("var type = typeof(T);\n");

                    using (builder.BeginScope($"if (type == typeof(IBaseEntity))"))
                    {
                        builder.AppendLine($"return (this as T)!;");
                    }

                    foreach (var entityName in entityList)
                    {
                        using (builder.BeginScope($"if (type == typeof({entityName}))"))
                        {
                            builder.AppendLine($"return ({entityName.Substring(1)}.Create(_this) as T)!;");
                        }
                    }

                    builder.AppendLine("""throw new NotSupportedException("Unsupported Entity Type");""");
                }
            }

            context.AddSource("BaseEntity.g.cs", builder.ToString());
        }
    }
}
