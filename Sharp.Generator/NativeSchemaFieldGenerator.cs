/* 
 * ModSharp
 * Copyright (C) 2023-2025 Kxnrl. All Rights Reserved.
 *
 * This file is part of ModSharp.
 * ModSharp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * ModSharp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with ModSharp. If not, see <https://www.gnu.org/licenses/>.
 */

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Sharp.Generator.Sdk.Utils;

namespace Sharp.Generator;

[Generator]
public class NativeSchemaFieldGenerator : IIncrementalGenerator
{
    private const string Namespace     = "Sharp.Generator";
    private const string AttributeName = "NativeSchemaFieldAttribute";

    private const string AttributeSourceCode = $$"""
                                                 // <auto-generated/>

                                                 namespace Sharp.Generator
                                                 {
                                                     [System.AttributeUsage(System.AttributeTargets.Method)]
                                                     internal class NativeSchemaFieldAttribute : System.Attribute
                                                     {
                                                         public string      ClassName    { get; set; }
                                                         public string      FieldName    { get; set; }
                                                         public System.Type ValueType    { get; set; }
                                                         public System.Type CastType     { get; set; }
                                                         public System.Type ReturnType   { get; set; }
                                                         public bool        IsStruct     { get; set; }
                                                         public bool        InlineObject { get; set; }
                                                         public bool        Nullable     { get; set; }
                                                         public bool        Validate     { get; set; }

                                                         public NativeSchemaFieldAttribute(string className, string fieldName, System.Type valueType)
                                                         {
                                                             ClassName = className;
                                                             FieldName = fieldName;
                                                             ValueType = valueType;
                                                         }

                                                         public NativeSchemaFieldAttribute(string className, string fieldName)
                                                         {
                                                             ClassName = className;
                                                             FieldName = fieldName;
                                                         }
                                                     }
                                                 }
                                                 """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{AttributeName}.g.cs",
                                                                      SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var provider = context.SyntaxProvider.CreateSyntaxProvider((x, _) => x is MethodDeclarationSyntax node
                                                                             && node.AttributeLists
                                                                                    .SelectMany(a => a.Attributes)
                                                                                    .Any(a => a.Name.ToString()
                                                                                        == AttributeName.Replace(
                                                                                            "Attribute",
                                                                                            "")),
                                                                   (x, _) => (MethodDeclarationSyntax) x.Node);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
                                     (spc, source) => Execute(spc, source.Left, source.Right));
    }

    private void Execute(SourceProductionContext context,
        Compilation                              compilation,
        ImmutableArray<MethodDeclarationSyntax>  methodDeclarations)
    {
        var group                 = methodDeclarations.GroupBy(x => x.Parent).ToList();
        var typeList              = group.Select(x => x.Key).OfType<TypeDeclarationSyntax>();
        var pendingValidateFields = new List<(string, string, string?, bool)>();

        foreach (var classDeclarationSyntax in typeList)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
            {
                continue;
            }

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            var className = classDeclarationSyntax.Identifier.Text;

            var builder = new CodeWriter();

            builder.AppendLine($"""
                                // <auto-generated/>

                                #pragma warning disable 0649
                                #nullable enable

                                using System;
                                using System.Runtime.InteropServices;
                                using System.Text;
                                using System.Text.Unicode;

                                namespace {namespaceName};

                                """);

            using (builder.BeginScope($"unsafe partial class {classSymbol.Name}"))
            {
                var methods = group.First(x => x.Key == classDeclarationSyntax);

                foreach (var methodSyntax in methods)
                {
                    var method = semanticModel.GetDeclaredSymbol(methodSyntax);

                    if (method is not IMethodSymbol methodSymbol)
                    {
                        continue;
                    }

                    // get attribute data
                    var schemaClassName = "";
                    var schemaFieldName = "";

                    var valueTypeStr        = "";
                    var isEnum              = false;
                    var isValueNativeObject = false;
                    var isValueSizableList  = false;
                    var isValueInlineArray  = false;

                    var castType     = "";
                    var returnType   = "";
                    var inlineObject = false;
                    var isStruct     = false;
                    var isNullable   = false;
                    var validate     = false;

                    var castTypeInterface = "";

                    foreach (var attributeArg in method.GetAttributes().First().NamedArguments)
                    {
                        if (attributeArg is { Key: "ClassName" })
                        {
                            schemaClassName = (string) attributeArg.Value.Value!;
                        }
                        else if (attributeArg is { Key: "FieldName" })
                        {
                            schemaFieldName = (string) attributeArg.Value.Value!;
                        }
                        else if (attributeArg is { Key: "CastType" })
                        {
                            if (attributeArg.Value.Value is INamedTypeSymbol type)
                            {
                                castType = type.ToString();

                                if (type.TypeKind == TypeKind.Class)
                                {
                                    if (type.Interfaces.FirstOrDefault() is { } castTypeInterfaceSymbol)
                                    {
                                        castTypeInterface = type.Interfaces.FirstOrDefault()?.ToString()
                                                            ?? "UnknownInterface";

                                        // 带有泛型的类型 将泛型类型转换为接口类型
                                        if (castTypeInterfaceSymbol.TypeArguments.FirstOrDefault()
                                            is { } genericTypeInterfaceSymbol)
                                        {
                                            var implName = genericTypeInterfaceSymbol.ToString();

                                            var interfaceName
                                                = genericTypeInterfaceSymbol.Interfaces.FirstOrDefault()?.ToString()
                                                  ?? "UnknownInterface";

                                            castTypeInterface = castTypeInterface.Replace(implName, interfaceName);
                                        }
                                    }
                                }
                            }
                        }
                        else if (attributeArg is { Key: "Nullable" })
                        {
                            isNullable = (bool) attributeArg.Value.Value!;
                        }
                        else if (attributeArg is { Key: "Validate" })
                        {
                            validate = (bool) attributeArg.Value.Value!;
                        }
                        else if (attributeArg is { Key: "ReturnType" })
                        {
                            if (attributeArg.Value.Value is INamedTypeSymbol type)
                            {
                                returnType = type.ToString();
                            }
                        }
                        else if (attributeArg is { Key: "InlineObject" })
                        {
                            inlineObject = (bool) attributeArg.Value.Value!;
                        }
                        else if (attributeArg is { Key: "IsStruct" })
                        {
                            isStruct = (bool) attributeArg.Value.Value!;
                        }
                    }

                    var count = 0;

                    foreach (var attributeArg in method.GetAttributes().First().ConstructorArguments)
                    {
                        if (count == 0)
                        {
                            schemaClassName = (string) attributeArg.Value!;
                        }
                        else if (count == 1)
                        {
                            schemaFieldName = (string) attributeArg.Value!;
                        }
                        else if (count == 2)
                        {
                            if (attributeArg.Value is ITypeSymbol { TypeKind: TypeKind.Enum })
                            {
                                isEnum = true;
                            }

                            if (attributeArg.Value is INamedTypeSymbol type)
                            {
                                valueTypeStr = type.ToString();

                                if (type.TypeKind == TypeKind.Class)
                                {
                                    if (type.IsAssignableFrom("INativeObject"))
                                    {
                                        isValueNativeObject = true;
                                    }

                                    if (type.IsAssignableFrom("ISchemaList"))
                                    {
                                        isValueSizableList = true;
                                    }

                                    if (type.Interfaces.FirstOrDefault() is { } castTypeInterfaceSymbol)
                                    {
                                        castTypeInterface = type.Interfaces.FirstOrDefault()?.ToString()
                                                            ?? "UnknownInterface";

                                        // 带有泛型的类型 将泛型类型转换为接口类型
                                        if (castTypeInterfaceSymbol.TypeArguments.FirstOrDefault()
                                            is { } genericTypeInterfaceSymbol)
                                        {
                                            var implName = genericTypeInterfaceSymbol.ToString();

                                            var interfaceName
                                                = genericTypeInterfaceSymbol.Interfaces.FirstOrDefault()?.ToString()
                                                  ?? "UnknownInterface";

                                            castTypeInterface = castTypeInterface.Replace(implName, interfaceName);
                                        }
                                    }
                                }
                            }
                            else if (attributeArg.Value is IArrayTypeSymbol arrayType)
                            {
                                valueTypeStr       = arrayType.ToString().Replace("[]", "");
                                isValueInlineArray = true;
                            }
                        }

                        count++;
                    }

                    if (!string.IsNullOrEmpty(returnType))
                    {
                        castTypeInterface = returnType;
                    }

                    var methodName   = methodSymbol.Name;
                    var propertyName = methodName.Substring(3, methodName.Length - 3 - 5);

                    // prepare field to store offset
                    builder.AppendLine($"private static Sharp.Shared.SchemaField? __{propertyName}SchemaField;");

                    // offset getter
                    using (builder.BeginScope(
                               $"{methodSymbol.DeclaredAccessibility.ToString().ToLower()} partial Sharp.Shared.SchemaField {methodName}()"))
                    {
                        builder.AppendLine(
                            $"__{propertyName}SchemaField ??= Sharp.Core.Helpers.SchemaSystem.GetSchemaField(\"{schemaClassName}\", \"{schemaFieldName}\");");

                        builder.AppendLine($"return __{propertyName}SchemaField;");
                    }

                    // add field to pending validate
                    pendingValidateFields.Add((schemaClassName, schemaFieldName, valueTypeStr, isEnum));

                    // prepare property (no valueType then dont add property)
                    if (!string.IsNullOrEmpty(valueTypeStr))
                    {
                        if (isValueNativeObject)
                        {
                            if (isValueSizableList)
                            {
                                using (builder.BeginScope($"public {castTypeInterface} Get{propertyName}()"))
                                {
                                    if (validate)
                                    {
                                        builder.AppendLine("CheckDisposed();");
                                    }

                                    builder.AppendLine(
                                        $"__{propertyName}SchemaField ??= Sharp.Core.Helpers.SchemaSystem.GetSchemaField(\"{schemaClassName}\", \"{schemaFieldName}\");");

                                    var dereferenceString = !inlineObject ? "*(nint*) " : "";
                                    var structString      = isStruct ? "true" : "false";

                                    builder.AppendLine(
                                        $"return {valueTypeStr}.Create({dereferenceString}IntPtr.Add(_this, __{propertyName}SchemaField.Offset), __{propertyName}SchemaField, _this, {structString})!;");
                                }
                            }
                            else
                            {
                                var nullableReturn = isNullable ? "?" : "";
                                var nullableString = isNullable ? "" : "!";

                                // is native object
                                using (builder.BeginScope($"public {castTypeInterface}{nullableReturn} Get{propertyName}()"))
                                {
                                    builder.AppendLine(
                                        $"__{propertyName}SchemaField ??= Sharp.Core.Helpers.SchemaSystem.GetSchemaField(\"{schemaClassName}\", \"{schemaFieldName}\");");

                                    var dereferenceString = !inlineObject ? "*(nint*) " : "";

                                    builder.AppendLine(
                                        $"return {valueTypeStr}.Create({dereferenceString}IntPtr.Add(_this, __{propertyName}SchemaField.Offset)){nullableString};");
                                }
                            }
                        }
                        else if (isValueInlineArray)
                        {
                            if (valueTypeStr == "char") // csharp char is 2 byte, c++ wont use it, so we use it for string
                            {
                                using (builder.BeginScope($"public void Set{propertyName}Local(string value)"))
                                {
                                    if (validate)
                                    {
                                        builder.AppendLine("CheckDisposed();");
                                    }

                                    builder.AppendLine(
                                        $"__{propertyName}SchemaField ??= Sharp.Core.Helpers.SchemaSystem.GetSchemaField(\"{schemaClassName}\", \"{schemaFieldName}\");");

                                    builder.AppendLine(
                                        $"var bytes = new Span<byte>((byte*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset), __{propertyName}SchemaField.ArraySize);");

                                    builder.AppendLine("Utf8.FromUtf16(value, bytes, out _, out var bytesWritten);");

                                    builder.AppendLine(
                                        $"bytes[bytesWritten >= __{propertyName}SchemaField.ArraySize ? bytesWritten - 1 : bytesWritten] = 0;");
                                }

                                using (builder.BeginScope($"public string {propertyName}"))
                                {
                                    using (builder.BeginScope("get"))
                                    {
                                        if (validate)
                                        {
                                            builder.AppendLine("CheckDisposed();");
                                        }

                                        builder.AppendLine(
                                            $"__{propertyName}SchemaField ??= Sharp.Core.Helpers.SchemaSystem.GetSchemaField(\"{schemaClassName}\", \"{schemaFieldName}\");");

                                        builder.AppendLine(
                                            $"return Sharp.Shared.Utilities.NativeString.ReadString(IntPtr.Add(_this, __{propertyName}SchemaField.Offset));");
                                    }

                                    using (builder.BeginScope("set"))
                                    {
                                        if (validate)
                                        {
                                            builder.AppendLine("CheckDisposed();");
                                        }

                                        builder.AppendLine(
                                            $"__{propertyName}SchemaField ??= Sharp.Core.Helpers.SchemaSystem.GetSchemaField(\"{schemaClassName}\", \"{schemaFieldName}\");");

                                        builder.AppendLine(
                                            $"var bytes = new Span<byte>((byte*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset), __{propertyName}SchemaField.ArraySize);");

                                        builder.AppendLine("Utf8.FromUtf16(value, bytes, out _, out var bytesWritten);");

                                        builder.AppendLine(
                                            $"bytes[bytesWritten >= __{propertyName}SchemaField.ArraySize ? bytesWritten - 1 : bytesWritten] = 0;");

                                        using (builder.BeginScope($"if (__{propertyName}SchemaField.Networked)"))
                                        {
                                            using (builder.BeginScope($"if (__{propertyName}SchemaField.ChainOffset > 0)"))
                                            {
                                                builder.AppendLine(
                                                    $"Bridges.Natives.Entity.NetworkStateChanged(IntPtr.Add(_this, __{propertyName}SchemaField.ChainOffset), (ushort) (__{propertyName}SchemaField.Offset));");
                                            }

                                            if (isStruct)
                                            {
                                                using (builder.BeginScope("else"))
                                                {
                                                    builder.AppendLine(
                                                        $"Bridges.Natives.Entity.SetStructStateChanged(IntPtr.Add(_this, __{propertyName}SchemaField.ChainOffset), (ushort) (__{propertyName}SchemaField.Offset));");
                                                }
                                            }
                                            else
                                            {
                                                using (builder.BeginScope("else"))
                                                {
                                                    builder.AppendLine(
                                                        $"Bridges.Natives.Entity.SetStateChanged(_this, (ushort) (__{propertyName}SchemaField.Offset));");
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else
                            {
                                // is inline array
                                using (builder.BeginScope(
                                           $"public Sharp.Shared.CStrike.ISchemaArray<{valueTypeStr}> Get{propertyName}()"))
                                {
                                    if (validate)
                                    {
                                        builder.AppendLine("CheckDisposed();");
                                    }

                                    builder.AppendLine(
                                        $"__{propertyName}SchemaField ??= Sharp.Core.Helpers.SchemaSystem.GetSchemaField(\"{schemaClassName}\", \"{schemaFieldName}\");");

                                    builder.AppendLine(
                                        $"return Sharp.Core.CStrike.SchemaFixedArray<{valueTypeStr}>.Create(IntPtr.Add(_this, __{propertyName}SchemaField.Offset), __{propertyName}SchemaField, _this)!;");
                                }
                            }
                        }
                        else if (valueTypeStr == "Sharp.Shared.Types.Tier.CUtlString")
                        {
                            using (builder.BeginScope($"public string {propertyName}"))
                            {
                                using (builder.BeginScope("get"))
                                {
                                    if (validate)
                                    {
                                        builder.AppendLine("CheckDisposed();");
                                    }

                                    builder.AppendLine(
                                        $"__{propertyName}SchemaField ??= Sharp.Core.Helpers.SchemaSystem.GetSchemaField(\"{schemaClassName}\", \"{schemaFieldName}\");");

                                    builder.AppendLine(
                                        $"return ((Sharp.Shared.Types.Tier.CUtlString*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset))->Get();");
                                }

                                using (builder.BeginScope("set"))
                                {
                                    if (validate)
                                    {
                                        builder.AppendLine("CheckDisposed();");
                                    }

                                    builder.AppendLine(
                                        $"__{propertyName}SchemaField ??= Sharp.Core.Helpers.SchemaSystem.GetSchemaField(\"{schemaClassName}\", \"{schemaFieldName}\");");

                                    builder.AppendLine(
                                        $"((Sharp.Shared.Types.Tier.CUtlString*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset))->SetString(value);");

                                    using (builder.BeginScope($"if (__{propertyName}SchemaField.Networked)"))
                                    {
                                        using (builder.BeginScope($"if (__{propertyName}SchemaField.ChainOffset > 0)"))
                                        {
                                            builder.AppendLine(
                                                $"Bridges.Natives.Entity.NetworkStateChanged(IntPtr.Add(_this, __{propertyName}SchemaField.ChainOffset), (ushort) (__{propertyName}SchemaField.Offset));");
                                        }

                                        if (isStruct)
                                        {
                                            using (builder.BeginScope("else"))
                                            {
                                                builder.AppendLine(
                                                    $"Bridges.Natives.Entity.SetStructStateChanged(IntPtr.Add(_this, __{propertyName}SchemaField.ChainOffset), (ushort) (__{propertyName}SchemaField.Offset));");
                                            }
                                        }
                                        else
                                        {
                                            using (builder.BeginScope("else"))
                                            {
                                                builder.AppendLine(
                                                    $"Bridges.Natives.Entity.SetStateChanged(_this, (ushort) (__{propertyName}SchemaField.Offset));");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else if (valueTypeStr == "Sharp.Shared.Types.Tier.CUtlSymbolLarge")
                        {
                            using (builder.BeginScope($"public string {propertyName}"))
                            {
                                using (builder.BeginScope("get"))
                                {
                                    if (validate)
                                    {
                                        builder.AppendLine("CheckDisposed();");
                                    }

                                    builder.AppendLine(
                                        $"__{propertyName}SchemaField ??= Sharp.Core.Helpers.SchemaSystem.GetSchemaField(\"{schemaClassName}\", \"{schemaFieldName}\");");

                                    builder.AppendLine(
                                        $"return ((Sharp.Shared.Types.Tier.CUtlSymbolLarge*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset))->Get();");
                                }

                                using (builder.BeginScope("set"))
                                {
                                    if (validate)
                                    {
                                        builder.AppendLine("CheckDisposed();");
                                    }

                                    builder.AppendLine(
                                        $"__{propertyName}SchemaField ??= Sharp.Core.Helpers.SchemaSystem.GetSchemaField(\"{schemaClassName}\", \"{schemaFieldName}\");");

                                    builder.AppendLine(
                                        $"var pointer = (Sharp.Shared.Types.Tier.CUtlSymbolLarge*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset);");

                                    builder.AppendLine(
                                        "var alloc = new Sharp.Shared.Types.Tier.CUtlSymbolLarge(Bridges.Natives.Entity.AllocPooledString(value));");

                                    builder.AppendLine("*pointer = alloc;");

                                    using (builder.BeginScope($"if (__{propertyName}SchemaField.Networked)"))
                                    {
                                        using (builder.BeginScope($"if (__{propertyName}SchemaField.ChainOffset > 0)"))
                                        {
                                            builder.AppendLine(
                                                $"Bridges.Natives.Entity.NetworkStateChanged(IntPtr.Add(_this, __{propertyName}SchemaField.ChainOffset), (ushort) (__{propertyName}SchemaField.Offset));");
                                        }

                                        if (isStruct)
                                        {
                                            using (builder.BeginScope("else"))
                                            {
                                                builder.AppendLine(
                                                    $"Bridges.Natives.Entity.SetStructStateChanged(IntPtr.Add(_this, __{propertyName}SchemaField.ChainOffset), (ushort) (__{propertyName}SchemaField.Offset));");
                                            }
                                        }
                                        else
                                        {
                                            using (builder.BeginScope("else"))
                                            {
                                                builder.AppendLine(
                                                    $"Bridges.Natives.Entity.SetStateChanged(_this, (ushort) (__{propertyName}SchemaField.Offset));");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else if (string.IsNullOrEmpty(castTypeInterface))
                        {
                            var finalType = string.IsNullOrEmpty(castType)
                                ? valueTypeStr
                                : castType;

                            using (builder.BeginScope($"public void Set{propertyName}Local({finalType} value)"))
                            {
                                BuildSetter(builder,
                                            valueTypeStr,
                                            propertyName,
                                            schemaClassName,
                                            schemaFieldName,
                                            castType,
                                            validate);
                            }

                            using (builder.BeginScope($"public {finalType} {propertyName}"))
                            {
                                using (builder.BeginScope("get"))
                                {
                                    if (validate)
                                    {
                                        builder.AppendLine("CheckDisposed();");
                                    }

                                    builder.AppendLine(
                                        $"__{propertyName}SchemaField ??= Sharp.Core.Helpers.SchemaSystem.GetSchemaField(\"{schemaClassName}\", \"{schemaFieldName}\");");

                                    if (valueTypeStr == "string")
                                    {
                                        builder.AppendLine(
                                            $"return new string((sbyte*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset));");
                                    }
                                    else if (valueTypeStr == "bool")
                                    {
                                        builder.AppendLine(
                                            $"return (*(byte*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset)) != 0;");
                                    }
                                    else if (string.IsNullOrEmpty(castType))
                                    {
                                        builder.AppendLine(
                                            $"return *({valueTypeStr}*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset);");
                                    }
                                    else
                                    {
                                        builder.AppendLine(
                                            $"return ({castType}) (*({valueTypeStr}*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset));");
                                    }
                                }

                                using (builder.BeginScope("set"))
                                {
                                    BuildSetter(builder,
                                                valueTypeStr,
                                                propertyName,
                                                schemaClassName,
                                                schemaFieldName,
                                                castType,
                                                validate);

                                    using (builder.BeginScope($"if (__{propertyName}SchemaField.Networked)"))
                                    {
                                        using (builder.BeginScope($"if (__{propertyName}SchemaField.ChainOffset > 0)"))
                                        {
                                            builder.AppendLine(
                                                $"Bridges.Natives.Entity.NetworkStateChanged(IntPtr.Add(_this, __{propertyName}SchemaField.ChainOffset), (ushort) (__{propertyName}SchemaField.Offset));");
                                        }

                                        if (isStruct)
                                        {
                                            using (builder.BeginScope("else"))
                                            {
                                                builder.AppendLine(
                                                    $"Bridges.Natives.Entity.SetStructStateChanged(IntPtr.Add(_this, __{propertyName}SchemaField.ChainOffset), (ushort) (__{propertyName}SchemaField.Offset));");
                                            }
                                        }
                                        else
                                        {
                                            using (builder.BeginScope("else"))
                                            {
                                                builder.AppendLine(
                                                    $"Bridges.Natives.Entity.SetStateChanged(_this, (ushort) (__{propertyName}SchemaField.Offset));");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    builder.AppendLine();
                }
            }

            context.AddSource($"{className}.g.cs", builder.ToString());
        }

        // add schema validate
        {
            var builder = new CodeWriter();

            builder.AppendLine($"""
                                // <auto-generated/>

                                #pragma warning disable 0649
                                #nullable enable

                                using System;
                                using System.Buffers;
                                using System.Text;
                                using System.Text.Unicode;
                                using System.Collections.Generic;
                                using System.Linq;

                                namespace SchemaValidate;

                                """);

            using (builder.BeginScope($"public static class SchemaValidator"))
            {
                builder.AppendLine("private static List<string> _errors = [];");

                using (builder.BeginScope($"public static unsafe bool Validate()"))
                {
                    foreach (var (schemaClassName, schemaFieldName, type, isEnum) in pendingValidateFields)
                    {
                        var sizeStr = !isEnum ? "0" : $"sizeof({type})";

                        builder.AppendLine(
                            $"ValidateField(\"{schemaClassName}\", \"{schemaFieldName}\", \"{type}\", {isEnum.ToString().ToLower()}, {sizeStr});");
                    }

                    builder.AppendLine($$"""
                                         if (_errors.Count > 0)
                                         {
                                             Console.WriteLine($"===> Schema validate failed {_errors.Count}");

                                             foreach (var err in _errors)
                                             {
                                                 Console.WriteLine(err);
                                             }
                                             
                                             return false;
                                         }

                                         return true;
                                         """);
                }

                using (builder.BeginScope(
                           "private static unsafe void ValidateField(string className, string fieldName, string? type, bool isEnum, int typeSize)"))
                {
                    builder.AppendLine($$"""

                                         if (!Sharp.Shared.SharedGameObject.SchemaInfo.TryGetValue(className, out var schemaClass))
                                         {
                                             _errors.Add($"{className} -> {fieldName} (Invalid class {className})");
                                             return;
                                         }

                                         if (!schemaClass.Fields.TryGetValue(fieldName, out var schemaField))
                                         {
                                             _errors.Add($"{className} -> {fieldName} (Invalid NetVar {fieldName} for class {schemaClass.ClassName})");
                                             return;
                                         }

                                         List<List<string>> sameTypes = [
                                             ["bool"],
                                             ["int8",       "sbyte"],
                                             ["uint8",      "byte", "Sharp.Shared.Enums.ObserverMode"],
                                             ["int16",      "short"],
                                             ["uint16",     "ushort"],
                                             ["int32",      "int",  "Sharp.Shared.Enums.CStrikeTeam"],
                                             ["uint32",     "uint"],
                                             ["int64",      "long"],
                                             ["uint64",     "ulong", "Sharp.Shared.Units.SteamID"],
                                             ["float32",    "float"],
                                             ["float64",    "double"],
                                             ["Vector",     "Sharp.Shared.Types.Vector"],
                                             ["GameTime_t", "float"],
                                         ];

                                         Dictionary<string, int> typeSizes = new ()
                                         {
                                             { "bool",      1 },
                                             { "int8",      1 },
                                             { "uint8",     1 },
                                             { "int16",     2 },
                                             { "uint16",    2 },
                                             { "int32",     4 },
                                             { "uint32",    4 },
                                             { "int64",     8 },
                                             { "uint64",    8 },
                                             { "float32",   4 },
                                             { "float64",   8 },
                                         };

                                         if (type is not null)
                                         {
                                             if (sameTypes.FirstOrDefault(x => x.Contains(schemaField.Type)) is {} sameType)
                                             {
                                                 if (!sameType.Contains(type))
                                                 {
                                                     if (!isEnum || typeSize != typeSizes[schemaField.Type])
                                                     {
                                                         _errors.Add($"{className} -> {fieldName} wrong type [{schemaField.Type} -> {type}]");
                                                     }
                                                 }
                                             }
                                         }

                                         """);
                }
            }

            context.AddSource("SchemaValidate.cs", builder.ToString());
        }
    }

    private void BuildSetter(CodeWriter builder,
        string?                         valueType,
        string                          propertyName,
        string                          schemaClassName,
        string                          schemaFieldName,
        string                          castType,
        bool                            validate)
    {
        if (validate)
        {
            builder.AppendLine("CheckDisposed();");
        }

        builder.AppendLine(
            $"__{propertyName}SchemaField ??= Sharp.Core.Helpers.SchemaSystem.GetSchemaField(\"{schemaClassName}\", \"{schemaFieldName}\");");

        if (valueType == "string")
        {
            builder.AppendLine(
                $"var bytes = new Span<byte>((byte*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset), __{propertyName}SchemaField.ArraySize);");

            builder.AppendLine("Utf8.FromUtf16(value, bytes, out _, out var bytesWritten);");

            builder.AppendLine(
                $"bytes[bytesWritten >= __{propertyName}SchemaField.ArraySize ? bytesWritten - 1 : bytesWritten] = 0;");
        }
        else if (valueType == "bool")
        {
            using (builder.BeginScope(
                       $"if (*(byte*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset) == (byte) (value ? 1 : 0))"))
            {
                builder.AppendLine("return;");
            }

            builder.AppendLine($"*(byte*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset) = (byte) (value ? 1 : 0);");
        }
        else if (string.IsNullOrEmpty(castType))
        {
            using (builder.BeginScope($"if (*({valueType}*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset) == value)"))
            {
                builder.AppendLine("return;");
            }

            builder.AppendLine($"*({valueType}*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset) = value;");
        }
        else
        {
            using (builder.BeginScope(
                       $"if (*({valueType}*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset) == ({valueType}) value)"))
            {
                builder.AppendLine("return;");
            }

            builder.AppendLine($"*({valueType}*) IntPtr.Add(_this, __{propertyName}SchemaField.Offset) = ({valueType}) value;");
        }
    }
}
