/* 
 * ModSharp
 * Copyright (C) 2023-2025 Kxnrl. All Rights Reserved.
 *
 * This file is part of ModSharp.
 * ModSharp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * ModSharp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with ModSharp. If not, see <https://www.gnu.org/licenses/>.
 */

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Sharp.Generator.Sdk.Utils;

namespace Sharp.Generator;

[Generator]
public class GameEventCreateGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName("Sharp.Core.GameEvents.GameEventNameAttribute",
                                                                           static (x, _) => x is ClassDeclarationSyntax,
                                                                           (gasc, _) => (ClassDeclarationSyntax) gasc
                                                                               .TargetNode);

        var compilation = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(compilation,
                                     (spc, source) => Execute(spc, source.Left, source.Right));
    }

    private void Execute(SourceProductionContext context,
        Compilation                              compilation,
        ImmutableArray<ClassDeclarationSyntax>   syntaxList)
    {
        var builder = new CodeWriter();

        var namespaceName = "Sharp.Core.Managers";
        var className     = "EventManager";

        builder.AppendLine($"""
                            // <auto-generated/>

                            #pragma warning disable 0649
                            #nullable enable

                            namespace {namespaceName};

                            """);

        var items = new List<(string EventName, string ClassName)>();

        foreach (var syntax in syntaxList)
        {
            var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(syntax) is not INamedTypeSymbol namedTypeSymbol)
            {
                continue;
            }

            var eventAttribute = namedTypeSymbol.GetAttributes()
                                                .FirstOrDefault(x => x.AttributeClass?.ToDisplayString()
                                                                     == "Sharp.Core.GameEvents.GameEventNameAttribute");

            if (eventAttribute is null)
            {
                continue;
            }

            var eventName = eventAttribute.ConstructorArguments.FirstOrDefault().Value as string;
            var name      = namedTypeSymbol.Name;

            items.Add((eventName!, name));
        }

        using (builder.BeginScope($"partial class {className}"))
        {
            using (builder.BeginScope(
                       $"public partial T? CreateEvent<T>(bool force) where T : class, global::Sharp.Shared.Objects.IGameEvent"))
            {
                foreach (var item in items)
                {
                    using (builder.BeginScope($"if (typeof(T) == typeof(global::Sharp.Shared.GameEvents.I{item.ClassName}))"))
                    {
                        builder.AppendLine(
                            $"""var ptr = global::Sharp.Core.Bridges.Natives.Event.CreateEvent("{item.EventName}", force);""");

                        builder.AppendLine(
                            $"return ptr == nint.Zero ? null : new global::Sharp.Core.GameEvents.{item.ClassName}(ptr, true) as T;");
                    }
                }

                builder.AppendLine("""throw new System.NotSupportedException("Unsupported generic game event type");""");
            }

            using (builder.BeginScope(
                       $"public partial T? CloneEvent<T>(T @event) where T : class, global::Sharp.Shared.Objects.IGameEvent"))
            {
                using (builder.BeginScope($"if (typeof(T) == typeof(global::Sharp.Shared.Objects.IGameEvent))"))
                {
                    builder.AppendLine(
                        "return global::Sharp.Core.Objects.GameEvent.CreateEditable(global::Sharp.Core.Bridges.Natives.Event.CloneEvent(@event.GetAbsPtr())) as T;");
                }

                foreach (var item in items)
                {
                    using (builder.BeginScope($"if (typeof(T) == typeof(global::Sharp.Shared.GameEvents.I{item.ClassName}))"))
                    {
                        builder.AppendLine(
                            "var ptr = global::Sharp.Core.Bridges.Natives.Event.CloneEvent(@event.GetAbsPtr());");

                        builder.AppendLine(
                            $"return ptr == nint.Zero ? null : new global::Sharp.Core.GameEvents.{item.ClassName}(ptr, true) as T;");
                    }
                }

                builder.AppendLine("""throw new System.NotSupportedException("Unsupported generic game event type");""");
            }

            using (builder.BeginScope(
                       "private partial global::Sharp.Shared.Objects.IGameEvent? MakeEvent(string name, nint ptr, bool editable)"))
            {
                using (builder.BeginScope("if (ptr == nint.Zero)"))
                {
                    builder.AppendLine("return null;");
                }

                using (builder.BeginScope("switch (name)"))
                {
                    foreach (var item in items)
                    {
                        using (builder.BeginScope($"case \"{item.EventName}\":"))
                        {
                            builder.AppendLine($"return new global::Sharp.Core.GameEvents.{item.ClassName}(ptr, editable);");
                        }
                    }
                }

                builder.AppendLine("return global::Sharp.Core.Objects.GameEvent.Create(ptr, name, editable);");
            }
        }

        context.AddSource("CreateGameEvent.g.cs", builder.ToString());
    }
}
