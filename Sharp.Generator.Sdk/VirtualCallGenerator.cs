/*
 * ModSharp
 * Copyright (C) 2023-2025 Kxnrl. All Rights Reserved.
 *
 * This file is part of ModSharp.
 * ModSharp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * ModSharp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with ModSharp. If not, see <https://www.gnu.org/licenses/>.
 */

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Sharp.Generator.Sdk.Utils;

namespace Sharp.Generator.Sdk;

[Generator]
public class VirtualCallGenerator : IIncrementalGenerator
{
    private const string Namespace     = "Sharp.Shared.Calls";
    private const string InterfaceName = "IVirtualCall";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider((x, _) => x is InterfaceDeclarationSyntax,
                                                                   (x, _) => GetInterfaceDeclarationForSourceGen(x))
                              .Where(t => t.interfaceFound)
                              .Select((t, _) => t.Item1);

        var compilation = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(compilation,
                                     (spc, source) => Execute(spc, source.Left, source.Right));
    }

    private static (InterfaceDeclarationSyntax, bool interfaceFound)
        GetInterfaceDeclarationForSourceGen(GeneratorSyntaxContext context)
    {
        var interfaceDeclarationSyntax = (InterfaceDeclarationSyntax) context.Node;

        if (context.SemanticModel.GetDeclaredSymbol(interfaceDeclarationSyntax) is INamedTypeSymbol interfaceSymbol)
        {
            if (interfaceSymbol.AllInterfaces.Any(x => x.ToDisplayString().StartsWith($"{Namespace}.{InterfaceName}")))
            {
                return (interfaceDeclarationSyntax, true);
            }
        }

        return (interfaceDeclarationSyntax, false);
    }

    private void Execute(SourceProductionContext   context,
        Compilation                                compilation,
        ImmutableArray<InterfaceDeclarationSyntax> interfacesDeclarations)
    {
        foreach (var interfaceDeclarationSyntax in interfacesDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(interfaceDeclarationSyntax.SyntaxTree);

            if (semanticModel.GetDeclaredSymbol(interfaceDeclarationSyntax) is not INamedTypeSymbol interfaceSymbol)
            {
                continue;
            }

            var namespaceName = interfaceSymbol.ContainingNamespace.ToDisplayString();

            var interName = interfaceDeclarationSyntax.Identifier.Text;
            var className = interfaceDeclarationSyntax.Identifier.Text.Substring(1);

            var builder = new CodeWriter();

            var genericType =
                interfaceSymbol.Interfaces.FirstOrDefault()?.TypeArguments.FirstOrDefault()?.ToDisplayString()
                ?? "object";

            builder.AppendLine($"""
                                // <auto-generated/>

                                #pragma warning disable 0649
                                #nullable enable

                                using System;
                                using System.Buffers;
                                using System.Reflection;
                                using System.Text;
                                using System.Text.Unicode;
                                using Sharp.Shared;
                                using Sharp.Shared.CStrike;

                                namespace {namespaceName};

                                """);

            using (builder.BeginScope($"unsafe partial class {className}: {interName}"))
            {
                var methods = interfaceSymbol.GetMembers();

                var offsetKeys = new List<(string name, string variable)>();

                foreach (var method in methods)
                {
                    if (method is not IMethodSymbol methodSymbol)
                    {
                        continue;
                    }

                    var fnParams                       = methodSymbol.GetParams();
                    var delegateUnmanagedPointerString = fnParams.GetDelegateUnmanagedPointerString();

                    builder.AppendLine($"private readonly int _{methodSymbol.Name}Offset;");

                    using (builder.BeginScope(
                               $"public {methodSymbol.ReturnType} {methodSymbol.Name}({fnParams.GetParametersString()})"))
                    {
                        if (fnParams.Params.FirstOrDefault()?.IsNativeObject ?? false)
                        {
                            builder.AppendLine(
                                $"var call = ({delegateUnmanagedPointerString})(*(nint*)(*(nint*) instance.GetAbsPtr() + 8 * _{methodSymbol.Name}Offset));");
                        }
                        else
                        {
                            builder.AppendLine(
                                $"var call = ({delegateUnmanagedPointerString})(*(nint*)(*(nint*) instance + 8 * _{methodSymbol.Name}Offset));");
                        }

                        builder.AppendLine();

                        fnParams.BuildUtf8ConvertCode(builder);

                        fnParams.BuildCallAndReturnDelegateUnmanagedPointer(builder, "call");
                    }

                    builder.AppendLine();

                    offsetKeys.Add((methodSymbol.Name, $"_{methodSymbol.Name}Offset"));
                }

                using (builder.BeginScope($"public {className}(IGameData gameData)"))
                {
                    using (builder.BeginScope(
                               $$"""if (typeof({{genericType}}).GetCustomAttribute<Sharp.Shared.Attributes.NetClassAttribute>() is not { } netClassAttribute)"""))
                    {
                        builder.AppendLine(
                            $"""throw new InvalidOperationException("{genericType} does not have NetClassAttribute");""");
                    }

                    builder.AppendLine("var className = netClassAttribute.Name;");

                    foreach (var (name, variable) in offsetKeys)
                    {
                        builder.AppendLine($"""{variable} = gameData.GetVFuncIndex(className, "{name}");""");
                    }
                }
            }

            context.AddSource($"{className}.g.cs", builder.ToString());
        }
    }
}
