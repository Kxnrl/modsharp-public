/* 
 * ModSharp
 * Copyright (C) 2023-2025 Kxnrl. All Rights Reserved.
 *
 * This file is part of ModSharp.
 * ModSharp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * ModSharp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with ModSharp. If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef CSTRIKE_TYPE_KEYVALUES_H
#define CSTRIKE_TYPE_KEYVALUES_H

#include "cstrike/type/Color32.h"

#include <cstddef>
#include <cstdint>

class CUtlBuffer;
class KeyValues;

class CKeyValues_Data
{
public:
    // Data type
    enum types_t
    {
        TYPE_NONE = 0,
        TYPE_STRING,
        TYPE_INT,
        TYPE_FLOAT,
        TYPE_PTR,
        TYPE_WSTRING,
        TYPE_COLOR,
        TYPE_UINT64,
        TYPE_COMPILED_INT_BYTE, // hack to collapse 1 byte ints in the compiled format
        TYPE_COMPILED_INT_0,    // hack to collapse 0 in the compiled format
        TYPE_COMPILED_INT_1,    // hack to collapse 1 in the compiled format
        TYPE_NUMTYPES,
    };

private:
    union {
        int            m_iValue;
        float          m_flValue;
        void*          m_pValue;
        unsigned char  m_Color[4];
        uintptr_t      m_uValue;
        const char*    m_sValue;
        const wchar_t* m_wsValue;
        KeyValues*     m_pSub;
    };

    void* m_pUnk;

    uint32_t m_iKeyNameCaseSensitive : 24;
    uint32_t m_iDataType : 3;
    uint32_t m_bHasEscapeSequences : 1;
    uint32_t m_bAllocatedExternalMemory : 1;
    uint32_t m_bKeySymbolCaseSensitiveMatchesCaseInsensitive : 1;
    uint32_t m_bStoredSubKey : 1;
};

#pragma pack(push, 1)
class KeyValues : public CKeyValues_Data
{
public:
    KeyValues(const char* setName, void* kvsystem = nullptr, bool unkState = false);
    ~KeyValues();

    bool LoadFromBuffer(const char* resourceName, const char* pBuffer, void* pFileSystem = nullptr, const char* pPathID = nullptr, void* pfnEvaluateSymbolProc = nullptr, void* pErrorSpew = nullptr, void* pUnk1 = nullptr, const char* pUnk2 = nullptr);
    bool LoadFromBuffer(const char* resourceName, CUtlBuffer& buf, void* pFileSystem = nullptr, const char* pPathID = nullptr, void* pfnEvaluateSymbolProc = nullptr, void* pErrorSpew = nullptr, void* pUnk1 = nullptr, const char* pUnk2 = nullptr);

    void        SetName(const char* name);
    const char* GetName() const;

    KeyValues*       FindKey(const char* keyName, bool bCreate = false);
    const KeyValues* FindKey(const char* keyName) const;

    KeyValues* AddKey(const char* keyName); // creates a new key, with an autogenerated name.  name is guaranteed to be an integer, of value 1 higher than the highest other integer key name

    KeyValues* GetFirstSubKey();
    KeyValues* FindLastSubKey();
    bool       FindAndDeleteSubKey(const char* name);

    KeyValues* GetNextKey();

    KeyValues* GetFirstTrueSubKey();
    KeyValues* GetNextTrueSubKey();

    KeyValues* GetFirstValue(); // When you get a value back, you can use GetX and pass in NULL to get the value.
    KeyValues* GetNextValue();

    int      GetInt(const char* keyName = nullptr, int defaultValue = 0) const;
    uint64_t GetUint64(const char* keyName = nullptr, uint64_t defaultValue = 0) const;
    float    GetFloat(const char* keyName = nullptr, float defaultValue = 0.0f) const;

private:
    const char* Internal_GetString(const char* keyName, const char* defaultValue = "", char* pszOut = nullptr, size_t maxlen = 0);

public:
    const char* GetString(const char* keyName, const char* defaultValue = "", char* pszOut = nullptr, size_t maxlen = 0);
    void*       GetPtr(const char* keyName = nullptr, void* defaultValue = (void*)nullptr) const;
    Color32     GetColor(const char* keyName = nullptr, const Color32& defaultColor = Color32(0, 0, 0, 0)) const;
    bool        GetBool(const char* keyName = nullptr, bool defaultValue = false) const { return GetInt(keyName, defaultValue ? 1 : 0) ? true : false; }
    bool        IsEmpty(const char* keyName = nullptr) const;

    void SetString(const char* keyName, const char* value);
    void SetInt(const char* keyName, int value);
    void SetUint64(const char* keyName, uint64_t value);
    void SetFloat(const char* keyName, float value);
    void SetPtr(const char* keyName, void* value);
    void SetColor(const char* keyName, Color32 value);
    void SetBool(const char* keyName, bool value) { SetInt(keyName, value ? 1 : 0); }

    KeyValues* MakeCopy();
    void       Clear();

    bool LoadFromFile(class IFileSystem* file_system, const char* filename, const char* path_id);
    bool SaveToFile(class IFileSystem* file_system, const char* filename, const char* path_id, bool allow_empty_string);
    void RecursiveSaveToFile(const CUtlBuffer& buf, int indent, bool sort, bool allow_empty_string);

    CKeyValues_Data::types_t GetDataType(const char* name);

private:
    KeyValues* m_pPeer; // pointer to next key in list
};
#pragma pack(pop)

#endif